PART1 jwt를 이용한 기본 인증 앱 생성하기
HTTP의 Serverless 특징(사용자들의 각 요청마다 사용자들의 신원) 때문에 인증 인가 과정이 필요하다
[인증 및 인가 절차 기본 흐름]
1. 유저가 자기 신원 밝힘
2. 서버는 유저의 정보를 포함하는 토큰을 생성하여 HTTP RESPONSE HEADER에 토큰을 붙여 클라이언트에게 응답메시지 보냄
3. 클라이언트는 토큰을 저장하고
4. 토큰을 요청 메시지에 실어 서버에 보냄
5. 서버가 토큰을 복호화해서 유저정보를 알게됨

[JWT] 
JSON Web Token는 데이터를 JSON 객체로 안전하게 전송하기 위한 표준. 
정보를 안전하게 전할 때 또는 유저의 권한 같은 것을 체크하기 위해 사용하기 위한 모듈

[JWT 구조]
HEADER, PAYLOAD, VERIFY SIGNATURE(VS)
HEADER: 토큰에 대한 메타 데이터(해싱 알고리즘, 타입 등)
PAYLOAD: 유저정보, 만료기간, 주제
VS: 토큰이 보낸 사람에 의해 서명되었고 어떤 식으로 변경되지 않았는지 확인하기 위해 사용하는 서명. 이 서명은 헤더 및 페이로드 세그먼트, 서명 알고리즘, 비밀 또는 공개 키를 사용하여 생성

ADMIN만 볼 수 있는 글을 보고자 할 때
요청을 보낼 때 보관하던 토큰을 헤더에 실어 서버에 보낸다.
서버는 JWT를 이용하여 토큰을 다시 생성한 후 2개를 비교한다.
*클라이언트가 보낸 JWT를 서버가 볼 때 서버는 진짜 ADMIN 유저인지를 확인한다. (토큰 유효성 여부, 페이로드 부분에 담겨있는 ADMIN 정보와 비교)
같으면 ADMIN 유저가 원하는 글을 볼 수 있다.

설치한 모듈 패키지
1. dotenv: 환경변수 생성을 위한 모듈
2. express
3. jsonwebtoken: 토큰 생성을 위한 모듈
4. nodemon

[액세스 토큰의 문제점]
처음 받은토큰을 이용해서 요청을 보낸다. 아직 유효하기 때문
유효기간이 짧으면 자주 로그아웃 자주 로그인
길다면, 토큰에 유효시간을 주는 이유가 사라진다 토큰이 탈취당하면 긴 유효기간이 끝날 때까지 탈취 당한 토큰을 사용 가능함.

[리프레쉬 토큰]
액세스 토큰의 유효시간은 짧게 리프레쉬 토큰은 길게 해준다. 그래서 액토 유효시간이 끝나면 리플 토큰을 이용해서 새 액토를 발급해주는 과정이다.
액토는 리소스에 접근하기 위해 사용하는 토큰
리토는 기존에 클이 가지고 있던 액토가 만료되었을 때 액토를새로 발급받기 위해 사용되는 토큰

1. 유저의 인증 요청
2. 액토와 리토 생성 그리고 유저에 전송
3. 클은 액토와 리토를 저장하고 액토를 담은 요청메시지 전송
4. 액토 검사 후 유효하면 보호된 리소스를 클에 전송
5. 이렇게 액토를 담은 요청메시지를 보내다가 액토의 유효시간이 만료되면 서버에서 유효성 검사 에러가 뜸
6. 유저는 리토를 서버에 전송
7. 서버는 다시 리토와 액토를 새로 생성하여 유저에 전송

액토의 유효시간 짧게
리토는 길게
리토는 쿠키에 저장하지만 주로 httpOnly 옵션을 줌으로써 js를 이용하여 리토를 탈취하거나 조작할 수 없게 만듦(xss cross site scripting 공격 방지)
액토는 쿠키나 localstorage, 메모리에 저장할 수 있다. (let accessToken =accessToken)
document.cookie
리토는 db에 저장해준다.

요청의 body를 받아오려면, req.body인 파싱한 것처럼,
쿠키를 받으려면, req.cookies로 파싱. 필요한 모듈은 cookie-parser
 이 파싱하는 단계에서 필요한 미들웨어 -> cookieParser

PART2 passport 모듈을 이용한 인증 앱 생성하기
passport 모듈을 통해 만들 앱에서는
1. 이메일과 비밀번호를 이용해서 로그인
2. 구글, 페이스북, 카카오 등의 아이디를 이용하는 OAuth 로그인
구현한다.

passport is a module to implement authentication and authorization

"dependencies": {
"body-parser": "^1.20.2",
"cookie-parser": "^1.4.6",
"cors": "^2.8.5",
"dotenv": "^16.3.1",
"express": "^4.18.2",
"jsonwebtoken": "^9.0.1",
"mongoose": "^7.4.2",
"nodemon": "^3.0.1",
"passport": "^0.6.0",
"passport-google-oauth20": "^2.0.0",
"passport-local": "^1.0.0"
}

[sparse : true]
이메일/비번 방식을 사용해서 로그인할 경우,
구글아이디 로그인 방식에서의 구글 아이디는 null값을 가진다.
2번째에서는 구글 아이디로 로그인
3번째에서 이메일/비번방식으로 로그인하면 구글 아이디는 null값을 가지나 구글 아이디 스키마에서 선언한 unique:true에 의해 첫번째 세번째 null 때문에 error가 발생한다. 이를 방지하기 위해
sparse: true